Depending on what exactly you are trying to do, the procedure to hunt down some moving line is roughly like this:

1) (optionally) demodulate some data around the frequency you are interested in, the narrower the better, since this will speed up later steps. This will 'zoom in' to the frequency interval f_demod - f_out/2 to f_demod + f_out /2. Note that f_out should be a nice integer frequency (e.g. 1, 2, 5, 10 ... Hz), to ensure that any data in the following steps had a nice time resolution as well. Also note that you will lose signal near the upper and lower edges of the frequency interval due to the anti-alias filter (at 80% of f_nyquist), so do take a bit of margin.

2) open the resulting file in spector.py, and play with the Fourier options (mainly the '<' and '>' keys for changing the length of the FFT window, in this way you can trade off frequency vs temporal resolution. You might also want to play with the 'color axis' by zooming in vertically on the top left plot, so that you can clearly see some feature you are interested in. If the data causes gaps due to unlocks, you can grey those out using the '9' key and clicking in the plot, see the included 'manual'. The last version normalizes the spectrum using the median, if you don't like this you can comment out line 236.

3) From this spectrogram, you somehow want to extract a time series, which you can do in two ways:
  a) by getting the frequency vs time for some moving line. This can be done by pressing the 'm' button (press another time to hide), which will highlight the maximum for every time slice with a red dot. This typically does however highlight the wrong line, so you might have to define an upper and lower search window with the 2 and 3 keys. (left click to add a point, right click to remove, 'd' to move all points of the current line). If you then press 'm' again, it will only search between the lines. Once you are happy with the result, you can press the 'M' button to save it to file (look for some xx.h5 file).

  b) By looking for the band-limited RMS (BRMS) vs time in a certain band. This is done by pressing the 'b' button, which will show the time BRMS time series in the top left plot (press another time to hide). As before, you calculate the BRMS only between two lines by defining an upper and lower lime. For the BRMS, you only want to use 2 straight lines. Ones you are happy with the result, press 'B' to save the file, look again for some xx.h5 file.

4) do a brute-force correlate of the resulting file with all (or many) of the channels in a certain FFL file. For this kind of long spectrograms, you typically want to correlate with trend.ffl. To reduce the number of channels a bit, I added a hard-coded blacklist in the source of correlator.py, you might have to edit this (this should become a command line option). You should set the target frequency the same as all the channels in the ffl file, so for trend.ffl this is 1 Hz. Doing the brute-force correlation will take minutes to hours, depending on the amount of channels in the ffl file and the length of the time series you are trying to correlate. The end result should be a text file with a ranking of the most correlated channels. What you want is channels that are clearly have a much lower residual than the others, and preferably channels that make some sense (some drifting temperature, some signal that indicates an on-off of a certain machine). In many cases, there is no good sensor that records the problem, so you will only find nonsensical correlations with many random channels with the same residual.

5) To make some follow up plots, you can use the plot_correlate.py script, using the same time series and settings as the correlator.py script, and in addition the name of a winning channel that you are interested in.

All the tools will give some information by calling the tool with command line option "-h".
